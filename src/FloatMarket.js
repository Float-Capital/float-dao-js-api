// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Ethers = require("ethers");
var FloatUtil = require("./FloatUtil.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var FloatEthers = require("./FloatEthers.js");
var FloatContracts = require("./FloatContracts.js");
var FloatMarketSide = require("./FloatMarketSide.js");
var FloatMarketTypes = require("./FloatMarketTypes.js");

function div(prim0, prim1) {
  return prim0.div(prim1);
}

function fromInt(prim) {
  return Ethers.BigNumber.from(prim);
}

function toNumber(prim) {
  return prim.toNumber();
}

var tenToThe18 = FloatEthers.BigNumber.tenToThe18;

function make(provider, marketIndex) {
  return {
          provider: provider,
          marketIndex: marketIndex
        };
}

function makeWrap(provider, marketIndex) {
  return FloatMarketTypes.wrapMarketP({
              provider: provider,
              marketIndex: marketIndex
            });
}

function makeWrapReverseCurry(marketIndex, provider) {
  return FloatMarketTypes.wrapMarketP({
              provider: provider,
              marketIndex: marketIndex
            });
}

var WithProvider = {
  make: make,
  makeWrap: makeWrap,
  makeWrapReverseCurry: makeWrapReverseCurry
};

function make$1(w, marketIndex) {
  return {
          wallet: w,
          marketIndex: marketIndex
        };
}

function makeWrap$1(w, marketIndex) {
  return FloatMarketTypes.wrapMarketW({
              wallet: w,
              marketIndex: marketIndex
            });
}

var WithWallet = {
  make: make$1,
  makeWrap: makeWrap$1
};

function makeUsingChain(chain, marketIndex) {
  if (chain.TAG === /* P */0) {
    return FloatMarketTypes.wrapMarketP({
                provider: chain._0.provider,
                marketIndex: marketIndex
              });
  } else {
    return FloatMarketTypes.wrapMarketW({
                wallet: chain._0.wallet,
                marketIndex: marketIndex
              });
  }
}

function provider(side) {
  if (side.TAG === /* P */0) {
    return side._0.provider;
  } else {
    return side._0.wallet.provider;
  }
}

function longSide(param, param$1) {
  return FloatMarketSide.WithProvider.makeWrapReverseCurry(true, param, param$1);
}

function shortSide(param, param$1) {
  return FloatMarketSide.WithProvider.makeWrapReverseCurry(false, param, param$1);
}

function makeLongShortContract(p, c) {
  return FloatContracts.LongShort.make(Ethers.utils.getAddress(c.contracts.longShort.address), p);
}

function makeStakerContract(p, c) {
  return FloatContracts.Staker.make(Ethers.utils.getAddress(c.contracts.longShort.address), p);
}

function claimFloatCustomFor(wallet, config, marketIndexes, address) {
  var partial_arg = makeStakerContract(FloatEthers.wrapWallet(wallet), config);
  return function (param) {
    return partial_arg.claimFloatCustomFor(marketIndexes, address, param);
  };
}

function settleOutstandingActions(wallet, config, marketIndex, address) {
  var partial_arg = makeLongShortContract(FloatEthers.wrapWallet(wallet), config);
  return function (param) {
    return partial_arg.executeOutstandingNextPriceSettlementsUser(address, marketIndex, param);
  };
}

function updateSystemState(wallet, config, marketIndex) {
  var partial_arg = makeLongShortContract(FloatEthers.wrapWallet(wallet), config);
  return function (param) {
    return partial_arg.updateSystemState(marketIndex, param);
  };
}

function contracts(market) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              return {
                      longToken: Caml_array.get(config.markets, market._0.marketIndex).longToken,
                      shortToken: Caml_array.get(config.markets, market._0.marketIndex).shortToken,
                      yieldManager: Caml_array.get(config.markets, market._0.marketIndex).yieldManager
                    };
            });
}

function leverage(market) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              var provider$1 = provider(market);
              var marketIndex = Ethers.BigNumber.from(market._0.marketIndex);
              return makeLongShortContract(FloatEthers.wrapProvider(provider$1), config).marketLeverage_e18(marketIndex).then(function (m) {
                          return m.div(tenToThe18).toNumber();
                        });
            });
}

function fundingRateMultiplier(market) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              return FloatMarketSide.fundingRateMultiplier(provider(market), config, Ethers.BigNumber.from(market._0.marketIndex));
            });
}

function syntheticTokenPrices(market) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              var provider$1 = provider(market);
              var marketIndex = market._0.marketIndex;
              return Promise.all([
                            FloatMarketSide.syntheticTokenPrice(longSide(marketIndex, provider$1)),
                            FloatMarketSide.syntheticTokenPrice(shortSide(marketIndex, provider$1))
                          ]).then(function (param) {
                          return {
                                  long: param[0],
                                  short: param[1]
                                };
                        });
            });
}

function exposures(market) {
  var provider$1 = provider(market);
  var marketIndex = market._0.marketIndex;
  return Promise.all([
                FloatMarketSide.exposure(longSide(marketIndex, provider$1)),
                FloatMarketSide.exposure(shortSide(marketIndex, provider$1))
              ]).then(function (param) {
              return {
                      long: param[0],
                      short: param[1]
                    };
            });
}

function unconfirmedExposures(market) {
  var provider$1 = provider(market);
  var marketIndex = market._0.marketIndex;
  return Promise.all([
                FloatMarketSide.unconfirmedExposure(longSide(marketIndex, provider$1)),
                FloatMarketSide.unconfirmedExposure(shortSide(marketIndex, provider$1))
              ]).then(function (param) {
              return {
                      long: param[0],
                      short: param[1]
                    };
            });
}

function fundingRateAprs(market) {
  var provider$1 = provider(market);
  var marketIndex = market._0.marketIndex;
  return Promise.all([
                FloatMarketSide.fundingRateApr(longSide(marketIndex, provider$1)),
                FloatMarketSide.fundingRateApr(shortSide(marketIndex, provider$1))
              ]).then(function (param) {
              return {
                      long: param[0],
                      short: param[1]
                    };
            });
}

function positions(market, ethAddress) {
  var provider$1 = provider(market);
  var marketIndex = market._0.marketIndex;
  return Promise.all([
                FloatMarketSide.positions(longSide(marketIndex, provider$1), undefined, ethAddress),
                FloatMarketSide.positions(shortSide(marketIndex, provider$1), undefined, ethAddress)
              ]).then(function (param) {
              return {
                      long: param[0],
                      short: param[1]
                    };
            });
}

function stakedPositions(market, ethAddress) {
  var provider$1 = provider(market);
  var marketIndex = market._0.marketIndex;
  return Promise.all([
                FloatMarketSide.stakedPositions(longSide(marketIndex, provider$1), undefined, ethAddress),
                FloatMarketSide.stakedPositions(shortSide(marketIndex, provider$1), undefined, ethAddress)
              ]).then(function (param) {
              return {
                      long: param[0],
                      short: param[1]
                    };
            });
}

function unsettledPositions(market, ethAddress) {
  var provider$1 = provider(market);
  var marketIndex = market._0.marketIndex;
  return Promise.all([
                FloatMarketSide.unsettledPositions(longSide(marketIndex, provider$1), ethAddress),
                FloatMarketSide.unsettledPositions(shortSide(marketIndex, provider$1), ethAddress)
              ]).then(function (param) {
              return {
                      long: param[0],
                      short: param[1]
                    };
            });
}

function claimFloatCustomFor$1(market, ethAddress, txOptions) {
  return FloatUtil.getChainConfig(FloatEthers.wrapWallet(market.wallet)).then(function (config) {
              var address = ethAddress !== undefined ? ethAddress : market.wallet._address;
              return claimFloatCustomFor(market.wallet, config, [Ethers.BigNumber.from(market.marketIndex)], Ethers.utils.getAddress(address))(txOptions);
            });
}

function settleOutstandingActions$1(market, ethAddress, txOptions) {
  return FloatUtil.getChainConfig(FloatEthers.wrapWallet(market.wallet)).then(function (config) {
              var address = ethAddress !== undefined ? ethAddress : market.wallet._address;
              return settleOutstandingActions(market.wallet, config, Ethers.BigNumber.from(market.marketIndex), Ethers.utils.getAddress(address))(txOptions);
            });
}

function updateSystemState$1(market, txOptions) {
  return FloatUtil.getChainConfig(FloatEthers.wrapWallet(market.wallet)).then(function (config) {
              return updateSystemState(market.wallet, config, Ethers.BigNumber.from(market.marketIndex))(txOptions);
            });
}

exports.div = div;
exports.fromInt = fromInt;
exports.toNumber = toNumber;
exports.tenToThe18 = tenToThe18;
exports.WithProvider = WithProvider;
exports.WithWallet = WithWallet;
exports.makeUsingChain = makeUsingChain;
exports.makeLongShortContract = makeLongShortContract;
exports.makeStakerContract = makeStakerContract;
exports.contracts = contracts;
exports.leverage = leverage;
exports.fundingRateMultiplier = fundingRateMultiplier;
exports.syntheticTokenPrices = syntheticTokenPrices;
exports.exposures = exposures;
exports.unconfirmedExposures = unconfirmedExposures;
exports.fundingRateAprs = fundingRateAprs;
exports.positions = positions;
exports.stakedPositions = stakedPositions;
exports.unsettledPositions = unsettledPositions;
exports.claimFloatCustomFor = claimFloatCustomFor$1;
exports.settleOutstandingActions = settleOutstandingActions$1;
exports.updateSystemState = updateSystemState$1;
/* ethers Not a pure module */
