// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Ethers = require("ethers");
var FloatUtil = require("./FloatUtil.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var FloatEthers = require("./FloatEthers.js");
var FloatContracts = require("./FloatContracts.js");
var FloatMarketSide = require("./FloatMarketSide.js");

function div(prim0, prim1) {
  return prim0.div(prim1);
}

function fromInt(prim) {
  return Ethers.BigNumber.from(prim);
}

function toNumber(prim) {
  return prim.toNumber();
}

var tenToThe18 = FloatEthers.BigNumber.tenToThe18;

function wrapSideP(side) {
  return {
          TAG: /* P */0,
          _0: side
        };
}

function wrapSideW(side) {
  return {
          TAG: /* W */1,
          _0: side
        };
}

function make(p, marketIndex) {
  return {
          provider: p,
          marketIndex: marketIndex
        };
}

function makeWrap(p, marketIndex) {
  return {
          TAG: /* P */0,
          _0: {
            provider: p,
            marketIndex: marketIndex
          }
        };
}

function makeWrapReverseCurry(marketIndex, p) {
  return {
          TAG: /* P */0,
          _0: {
            provider: p,
            marketIndex: marketIndex
          }
        };
}

var WithProvider = {
  make: make,
  makeWrap: makeWrap,
  makeWrapReverseCurry: makeWrapReverseCurry
};

function make$1(w, marketIndex) {
  return {
          wallet: w,
          marketIndex: marketIndex
        };
}

function makeWrap$1(w, marketIndex) {
  return {
          TAG: /* W */1,
          _0: {
            wallet: w,
            marketIndex: marketIndex
          }
        };
}

var WithWallet = {
  make: make$1,
  makeWrap: makeWrap$1
};

function provider(side) {
  if (side.TAG === /* P */0) {
    return side._0.provider;
  } else {
    return side._0.wallet.provider;
  }
}

function marketIndex(side) {
  return side._0.marketIndex;
}

function makeLongShortContract(p, c) {
  return FloatContracts.LongShort.make(Ethers.utils.getAddress(c.contracts.longShort.address), p);
}

function makeStakerContract(p, c) {
  return FloatContracts.Staker.make(Ethers.utils.getAddress(c.contracts.longShort.address), p);
}

function longSide(param, param$1) {
  return FloatMarketSide.WithProvider.makeWrapReverseCurry(true, param, param$1);
}

function shortSide(param, param$1) {
  return FloatMarketSide.WithProvider.makeWrapReverseCurry(false, param, param$1);
}

function claimFloatCustomFor(w, c, marketIndexes, address) {
  var partial_arg = makeStakerContract(FloatEthers.wrapWallet(w), c);
  return function (param) {
    return partial_arg.claimFloatCustomFor(marketIndexes, address, param);
  };
}

function settleOutstandingActions(w, c, marketIndex, address) {
  var partial_arg = makeLongShortContract(FloatEthers.wrapWallet(w), c);
  return function (param) {
    return partial_arg.executeOutstandingNextPriceSettlementsUser(address, marketIndex, param);
  };
}

function updateSystemState(w, c, marketIndex) {
  var partial_arg = makeLongShortContract(FloatEthers.wrapWallet(w), c);
  return function (param) {
    return partial_arg.updateSystemState(marketIndex, param);
  };
}

function contracts(market) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              return {
                      longToken: Caml_array.get(config.markets, market._0.marketIndex).longToken,
                      shortToken: Caml_array.get(config.markets, market._0.marketIndex).shortToken,
                      yieldManager: Caml_array.get(config.markets, market._0.marketIndex).yieldManager
                    };
            });
}

function leverage(market) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              var p = provider(market);
              var marketIndex = Ethers.BigNumber.from(market._0.marketIndex);
              return makeLongShortContract(FloatEthers.wrapProvider(p), config).marketLeverage_e18(marketIndex).then(function (m) {
                          return m.div(tenToThe18).toNumber();
                        });
            });
}

function fundingRateMultiplier(market) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              return FloatMarketSide.fundingRateMultiplier(provider(market), config, Ethers.BigNumber.from(market._0.marketIndex));
            });
}

function syntheticTokenPrices(market) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              var p = provider(market);
              var marketIndex = market._0.marketIndex;
              return Promise.all([
                            FloatMarketSide.syntheticTokenPrice(longSide(marketIndex, p)),
                            FloatMarketSide.syntheticTokenPrice(shortSide(marketIndex, p))
                          ]).then(function (param) {
                          return {
                                  long: param[0],
                                  short: param[1]
                                };
                        });
            });
}

function exposures(market) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              var p = provider(market);
              var marketIndex = market._0.marketIndex;
              return Promise.all([
                            FloatMarketSide.exposure(longSide(marketIndex, p)),
                            FloatMarketSide.exposure(shortSide(marketIndex, p))
                          ]).then(function (param) {
                          return {
                                  long: param[0],
                                  short: param[1]
                                };
                        });
            });
}

function unconfirmedExposures(market) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              var p = provider(market);
              var marketIndex = market._0.marketIndex;
              return Promise.all([
                            FloatMarketSide.unconfirmedExposure(longSide(marketIndex, p)),
                            FloatMarketSide.unconfirmedExposure(shortSide(marketIndex, p))
                          ]).then(function (param) {
                          return {
                                  long: param[0],
                                  short: param[1]
                                };
                        });
            });
}

function fundingRateAprs(market) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              var p = provider(market);
              var marketIndex = market._0.marketIndex;
              return Promise.all([
                            FloatMarketSide.fundingRateApr(longSide(marketIndex, p)),
                            FloatMarketSide.fundingRateApr(shortSide(marketIndex, p))
                          ]).then(function (param) {
                          return {
                                  long: param[0],
                                  short: param[1]
                                };
                        });
            });
}

function positions(market, ethAddress) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              var p = provider(market);
              var marketIndex = market._0.marketIndex;
              return Promise.all([
                            FloatMarketSide.positions(longSide(marketIndex, p), ethAddress),
                            FloatMarketSide.positions(shortSide(marketIndex, p), ethAddress)
                          ]).then(function (param) {
                          return {
                                  long: param[0],
                                  short: param[1]
                                };
                        });
            });
}

function stakedPositions(market, ethAddress) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              var p = provider(market);
              var marketIndex = market._0.marketIndex;
              return Promise.all([
                            FloatMarketSide.stakedPositions(longSide(marketIndex, p), ethAddress),
                            FloatMarketSide.stakedPositions(shortSide(marketIndex, p), ethAddress)
                          ]).then(function (param) {
                          return {
                                  long: param[0],
                                  short: param[1]
                                };
                        });
            });
}

function unsettledPositions(market, ethAddress) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              var p = provider(market);
              var marketIndex = market._0.marketIndex;
              return Promise.all([
                            FloatMarketSide.unsettledPositions(longSide(marketIndex, p), ethAddress),
                            FloatMarketSide.unsettledPositions(shortSide(marketIndex, p), ethAddress)
                          ]).then(function (param) {
                          return {
                                  long: param[0],
                                  short: param[1]
                                };
                        });
            });
}

function side(market, isLong) {
  if (market.TAG === /* P */0) {
    return FloatMarketSide.WithProvider.makeWrap(market._0.provider, market._0.marketIndex, isLong);
  } else {
    return FloatMarketSide.WithWallet.makeWrap(market._0.wallet, market._0.marketIndex, isLong);
  }
}

function connect(market, wallet, isLong) {
  return FloatMarketSide.WithWallet.make(wallet, market.marketIndex, isLong);
}

function connectWrap(market, wallet, isLong) {
  return FloatMarketSide.WithWallet.make(wallet, market._0.marketIndex, isLong);
}

function claimFloatCustomFor$1(market, ethAddress, txOptions) {
  return FloatUtil.getChainConfig(FloatEthers.wrapWallet(market.wallet)).then(function (config) {
              return claimFloatCustomFor(market.wallet, config, [Ethers.BigNumber.from(market.marketIndex)], ethAddress)(txOptions);
            });
}

function settleOutstandingActions$1(market, ethAddress, txOptions) {
  return FloatUtil.getChainConfig(FloatEthers.wrapWallet(market.wallet)).then(function (config) {
              return settleOutstandingActions(market.wallet, config, Ethers.BigNumber.from(market.marketIndex), ethAddress)(txOptions);
            });
}

function updateSystemState$1(market, txOptions) {
  return FloatUtil.getChainConfig(FloatEthers.wrapWallet(market.wallet)).then(function (config) {
              return updateSystemState(market.wallet, config, Ethers.BigNumber.from(market.marketIndex))(txOptions);
            });
}

exports.div = div;
exports.fromInt = fromInt;
exports.toNumber = toNumber;
exports.tenToThe18 = tenToThe18;
exports.wrapSideP = wrapSideP;
exports.wrapSideW = wrapSideW;
exports.WithProvider = WithProvider;
exports.WithWallet = WithWallet;
exports.provider = provider;
exports.marketIndex = marketIndex;
exports.makeLongShortContract = makeLongShortContract;
exports.makeStakerContract = makeStakerContract;
exports.longSide = longSide;
exports.shortSide = shortSide;
exports.contracts = contracts;
exports.leverage = leverage;
exports.fundingRateMultiplier = fundingRateMultiplier;
exports.syntheticTokenPrices = syntheticTokenPrices;
exports.exposures = exposures;
exports.unconfirmedExposures = unconfirmedExposures;
exports.fundingRateAprs = fundingRateAprs;
exports.positions = positions;
exports.stakedPositions = stakedPositions;
exports.unsettledPositions = unsettledPositions;
exports.side = side;
exports.connect = connect;
exports.connectWrap = connectWrap;
exports.claimFloatCustomFor = claimFloatCustomFor$1;
exports.settleOutstandingActions = settleOutstandingActions$1;
exports.updateSystemState = updateSystemState$1;
/* ethers Not a pure module */
