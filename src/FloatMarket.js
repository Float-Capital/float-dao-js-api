// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Ethers = require("ethers");
var FloatUtil = require("./FloatUtil.js");
var Caml_array = require("rescript/lib/js/caml_array.js");
var FloatEthers = require("./FloatEthers.js");
var FloatContracts = require("./FloatContracts.js");
var FloatMarketSide = require("./FloatMarketSide.js");

function div(prim0, prim1) {
  return prim0.div(prim1);
}

function fromInt(prim) {
  return Ethers.BigNumber.from(prim);
}

function toNumber(prim) {
  return prim.toNumber();
}

var tenToThe18 = FloatEthers.BigNumber.tenToThe18;

function wrapSideP(side) {
  return {
          TAG: /* P */0,
          _0: side
        };
}

function wrapSideW(side) {
  return {
          TAG: /* W */1,
          _0: side
        };
}

function make(p, marketIndex) {
  return {
          provider: p,
          marketIndex: marketIndex
        };
}

function makeWrap(p, marketIndex) {
  return {
          TAG: /* P */0,
          _0: {
            provider: p,
            marketIndex: marketIndex
          }
        };
}

function makeWrapReverseCurry(marketIndex, p) {
  return {
          TAG: /* P */0,
          _0: {
            provider: p,
            marketIndex: marketIndex
          }
        };
}

var WithProvider = {
  make: make,
  makeWrap: makeWrap,
  makeWrapReverseCurry: makeWrapReverseCurry
};

function make$1(w, marketIndex) {
  return {
          wallet: w,
          marketIndex: marketIndex
        };
}

function makeWrap$1(w, marketIndex) {
  return {
          TAG: /* W */1,
          _0: {
            wallet: w,
            marketIndex: marketIndex
          }
        };
}

var WithWallet = {
  make: make$1,
  makeWrap: makeWrap$1
};

function provider(side) {
  if (side.TAG === /* P */0) {
    return side._0.provider;
  } else {
    return side._0.wallet.provider;
  }
}

function marketIndex(side) {
  return side._0.marketIndex;
}

function makeLongShortContract(p, c) {
  return FloatContracts.LongShort.make(Ethers.utils.getAddress(c.contracts.longShort.address), p);
}

function makeStakerContract(p, c) {
  return FloatContracts.Staker.make(Ethers.utils.getAddress(c.contracts.longShort.address), p);
}

function leverage(p, c, marketIndex) {
  return makeLongShortContract(FloatEthers.wrapProvider(p), c).marketLeverage_e18(marketIndex).then(function (m) {
              return m.div(tenToThe18).toNumber();
            });
}

function longSide(param, param$1) {
  return FloatMarketSide.WithProvider.makeWrapReverseCurry(true, param, param$1);
}

function shortSide(param, param$1) {
  return FloatMarketSide.WithProvider.makeWrapReverseCurry(false, param, param$1);
}

function syntheticTokenPrices(p, c, marketIndex) {
  return Promise.all([
                FloatMarketSide.syntheticTokenPrice(longSide(marketIndex, p)),
                FloatMarketSide.syntheticTokenPrice(shortSide(marketIndex, p))
              ]).then(function (param) {
              return {
                      long: param[0],
                      short: param[1]
                    };
            });
}

function exposures(p, c, marketIndex) {
  return Promise.all([
                FloatMarketSide.exposure(longSide(marketIndex, p)),
                FloatMarketSide.exposure(shortSide(marketIndex, p))
              ]).then(function (param) {
              return {
                      long: param[0],
                      short: param[1]
                    };
            });
}

function unconfirmedExposures(p, c, marketIndex) {
  return Promise.all([
                FloatMarketSide.unconfirmedExposure(longSide(marketIndex, p)),
                FloatMarketSide.unconfirmedExposure(shortSide(marketIndex, p))
              ]).then(function (param) {
              return {
                      long: param[0],
                      short: param[1]
                    };
            });
}

function fundingRateAprs(p, c, marketIndex) {
  return Promise.all([
                FloatMarketSide.fundingRateApr(longSide(marketIndex, p)),
                FloatMarketSide.fundingRateApr(shortSide(marketIndex, p))
              ]).then(function (param) {
              return {
                      long: param[0],
                      short: param[1]
                    };
            });
}

function positions(p, c, marketIndex, address) {
  return Promise.all([
                FloatMarketSide.positions(longSide(marketIndex, p), address),
                FloatMarketSide.positions(shortSide(marketIndex, p), address)
              ]).then(function (param) {
              return {
                      long: param[0],
                      short: param[1]
                    };
            });
}

function stakedPositions(p, c, marketIndex, address) {
  return Promise.all([
                FloatMarketSide.stakedPositions(longSide(marketIndex, p), address),
                FloatMarketSide.stakedPositions(shortSide(marketIndex, p), address)
              ]).then(function (param) {
              return {
                      long: param[0],
                      short: param[1]
                    };
            });
}

function unsettledPositions(p, c, marketIndex, address) {
  return Promise.all([
                FloatMarketSide.unsettledPositions(longSide(marketIndex, p), address),
                FloatMarketSide.unsettledPositions(shortSide(marketIndex, p), address)
              ]).then(function (param) {
              return {
                      long: param[0],
                      short: param[1]
                    };
            });
}

function claimFloatCustomFor(w, c, marketIndexes, address) {
  var partial_arg = makeStakerContract(FloatEthers.wrapWallet(w), c);
  return function (param) {
    return partial_arg.claimFloatCustomFor(marketIndexes, address, param);
  };
}

function settleOutstandingActions(w, c, marketIndex, address) {
  var partial_arg = makeLongShortContract(FloatEthers.wrapWallet(w), c);
  return function (param) {
    return partial_arg.executeOutstandingNextPriceSettlementsUser(address, marketIndex, param);
  };
}

function updateSystemState(w, c, marketIndex) {
  var partial_arg = makeLongShortContract(FloatEthers.wrapWallet(w), c);
  return function (param) {
    return partial_arg.updateSystemState(marketIndex, param);
  };
}

function makeWithWallet(w, marketIndex) {
  return {
          getLeverage: (function (param) {
              return FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                          return leverage(w.provider, c, Ethers.BigNumber.from(marketIndex));
                        });
            }),
          getFundingRateMultiplier: (function (param) {
              return FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                          return FloatMarketSide.fundingRateMultiplier(w.provider, c, Ethers.BigNumber.from(marketIndex));
                        });
            }),
          getSyntheticTokenPrices: (function (param) {
              return FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                          return syntheticTokenPrices(w.provider, c, marketIndex);
                        });
            }),
          getExposures: (function (param) {
              return FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                          return exposures(w.provider, c, marketIndex);
                        });
            }),
          getUnconfirmedExposures: (function (param) {
              return FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                          return unconfirmedExposures(w.provider, c, marketIndex);
                        });
            }),
          getFundingRateAprs: (function (param) {
              return FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                          return fundingRateAprs(w.provider, c, marketIndex);
                        });
            }),
          getPositions: (function (ethAddress) {
              return FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                          return positions(w.provider, c, marketIndex, ethAddress);
                        });
            }),
          getStakedPositions: (function (ethAddress) {
              return FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                          return stakedPositions(w.provider, c, marketIndex, ethAddress);
                        });
            }),
          getUnsettledPositions: (function (ethAddress) {
              return FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                          return unsettledPositions(w.provider, c, marketIndex, ethAddress);
                        });
            }),
          claimFloatCustomFor: (function (ethAddress, txOptions) {
              return FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                          return claimFloatCustomFor(w, c, [Ethers.BigNumber.from(marketIndex)], ethAddress)(txOptions);
                        });
            }),
          settleOutstandingActions: (function (ethAddress, txOptions) {
              return FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                          return settleOutstandingActions(w, c, Ethers.BigNumber.from(marketIndex), ethAddress)(txOptions);
                        });
            }),
          updateSystemState: (function (txOptions) {
              return FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                          return updateSystemState(w, c, Ethers.BigNumber.from(marketIndex))(txOptions);
                        });
            }),
          getSide: (function (param) {
              return FloatMarketSide.WithWallet.make(w, marketIndex, param);
            })
        };
}

function makeWithProvider(p, marketIndex) {
  return {
          getLeverage: (function (param) {
              return FloatUtil.getChainConfig(FloatEthers.wrapProvider(p)).then(function (c) {
                          return leverage(p, c, Ethers.BigNumber.from(marketIndex));
                        });
            }),
          getFundingRateMultiplier: (function (param) {
              return FloatUtil.getChainConfig(FloatEthers.wrapProvider(p)).then(function (c) {
                          return FloatMarketSide.fundingRateMultiplier(p, c, Ethers.BigNumber.from(marketIndex));
                        });
            }),
          getSyntheticTokenPrices: (function (param) {
              return FloatUtil.getChainConfig(FloatEthers.wrapProvider(p)).then(function (c) {
                          return syntheticTokenPrices(p, c, marketIndex);
                        });
            }),
          getExposures: (function (param) {
              return FloatUtil.getChainConfig(FloatEthers.wrapProvider(p)).then(function (c) {
                          return exposures(p, c, marketIndex);
                        });
            }),
          getUnconfirmedExposures: (function (param) {
              return FloatUtil.getChainConfig(FloatEthers.wrapProvider(p)).then(function (c) {
                          return unconfirmedExposures(p, c, marketIndex);
                        });
            }),
          getFundingRateAprs: (function (param) {
              return FloatUtil.getChainConfig(FloatEthers.wrapProvider(p)).then(function (c) {
                          return fundingRateAprs(p, c, marketIndex);
                        });
            }),
          getPositions: (function (ethAddress) {
              return FloatUtil.getChainConfig(FloatEthers.wrapProvider(p)).then(function (c) {
                          return positions(p, c, marketIndex, ethAddress);
                        });
            }),
          getStakedPositions: (function (ethAddress) {
              return FloatUtil.getChainConfig(FloatEthers.wrapProvider(p)).then(function (c) {
                          return stakedPositions(p, c, marketIndex, ethAddress);
                        });
            }),
          getUnsettledPositions: (function (ethAddress) {
              return FloatUtil.getChainConfig(FloatEthers.wrapProvider(p)).then(function (c) {
                          return unsettledPositions(p, c, marketIndex, ethAddress);
                        });
            }),
          getSide: (function (isLong) {
              return FloatMarketSide.WithProvider.make(p, marketIndex, isLong);
            }),
          connect: (function (w, isLong) {
              return FloatMarketSide.WithWallet.make(w, marketIndex, isLong);
            })
        };
}

function contracts(market) {
  return FloatUtil.getChainConfig(FloatEthers.wrapProvider(provider(market))).then(function (config) {
              return {
                      longToken: Caml_array.get(config.markets, market._0.marketIndex).longToken,
                      shortToken: Caml_array.get(config.markets, market._0.marketIndex).shortToken,
                      yieldManager: Caml_array.get(config.markets, market._0.marketIndex).yieldManager
                    };
            });
}

exports.div = div;
exports.fromInt = fromInt;
exports.toNumber = toNumber;
exports.tenToThe18 = tenToThe18;
exports.wrapSideP = wrapSideP;
exports.wrapSideW = wrapSideW;
exports.WithProvider = WithProvider;
exports.WithWallet = WithWallet;
exports.provider = provider;
exports.marketIndex = marketIndex;
exports.makeLongShortContract = makeLongShortContract;
exports.makeStakerContract = makeStakerContract;
exports.leverage = leverage;
exports.longSide = longSide;
exports.shortSide = shortSide;
exports.syntheticTokenPrices = syntheticTokenPrices;
exports.exposures = exposures;
exports.unconfirmedExposures = unconfirmedExposures;
exports.fundingRateAprs = fundingRateAprs;
exports.positions = positions;
exports.stakedPositions = stakedPositions;
exports.unsettledPositions = unsettledPositions;
exports.claimFloatCustomFor = claimFloatCustomFor;
exports.settleOutstandingActions = settleOutstandingActions;
exports.updateSystemState = updateSystemState;
exports.makeWithWallet = makeWithWallet;
exports.makeWithProvider = makeWithProvider;
exports.contracts = contracts;
/* ethers Not a pure module */
