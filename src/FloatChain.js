// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Ethers = require("ethers");
var FloatUtil = require("./FloatUtil.js");
var FloatEthers = require("./FloatEthers.js");
var FloatMarket = require("./FloatMarket.js");
var FloatContracts = require("./FloatContracts.js");

function wrapChainWithProvider(p) {
  return {
          TAG: /* ChainPWrap */0,
          _0: p
        };
}

function wrapChainWithWallet(p) {
  return {
          TAG: /* ChainWWrap */1,
          _0: p
        };
}

function makeLongShortContract(p, c) {
  return FloatContracts.LongShort.make(Ethers.utils.getAddress(c.contracts.longShort.address), p);
}

function updateSystemStateMulti(w, c, marketIndexes) {
  var partial_arg = makeLongShortContract(FloatEthers.wrapWallet(w), c);
  return function (param) {
    return partial_arg.updateSystemStateMulti(marketIndexes, param);
  };
}

function makeWithWallet(w) {
  return {
          contracts: FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                return c.contracts;
              }),
          updateSystemState: (function (marketIndexes, txOptions) {
              return FloatUtil.getChainConfig(FloatEthers.wrapWallet(w)).then(function (c) {
                          return updateSystemStateMulti(w, c, marketIndexes)(txOptions);
                        });
            }),
          getMarket: (function (param) {
              return FloatMarket.makeWithWallet(w, param);
            })
        };
}

function makeWithProvider(p) {
  return {
          contracts: FloatUtil.getChainConfig(FloatEthers.wrapProvider(p)).then(function (c) {
                return c.contracts;
              }),
          getMarket: (function (param) {
              return FloatMarket.WithProvider.make(p, param);
            }),
          connect: makeWithWallet
        };
}

function makeWithDefaultProvider(chainId) {
  var partial_arg = FloatUtil.makeDefaultProvider(FloatUtil.getChainConfigUsingId(chainId));
  return {
          contracts: FloatUtil.getChainConfig(FloatEthers.wrapProvider(FloatUtil.makeDefaultProvider(FloatUtil.getChainConfigUsingId(chainId)))).then(function (c) {
                return c.contracts;
              }),
          getMarket: (function (param) {
              return FloatMarket.WithProvider.make(partial_arg, param);
            }),
          connect: makeWithWallet
        };
}

function make(pw) {
  if (pw.TAG === /* P */0) {
    return {
            TAG: /* ChainPWrap */0,
            _0: makeWithProvider(pw._0)
          };
  } else {
    return {
            TAG: /* ChainWWrap */1,
            _0: makeWithWallet(pw._0)
          };
  }
}

exports.wrapChainWithProvider = wrapChainWithProvider;
exports.wrapChainWithWallet = wrapChainWithWallet;
exports.makeLongShortContract = makeLongShortContract;
exports.updateSystemStateMulti = updateSystemStateMulti;
exports.makeWithWallet = makeWithWallet;
exports.makeWithProvider = makeWithProvider;
exports.makeWithDefaultProvider = makeWithDefaultProvider;
exports.make = make;
/* ethers Not a pure module */
