// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Ethers = require("ethers");
var FloatUtil = require("./FloatUtil.js");
var FloatEthers = require("./FloatEthers.js");
var FloatMarket = require("./FloatMarket.js");
var FloatContracts = require("./FloatContracts.js");

function wrapSideP(side) {
  return {
          TAG: /* P */0,
          _0: side
        };
}

function wrapSideW(side) {
  return {
          TAG: /* W */1,
          _0: side
        };
}

function make(p) {
  return {
          provider: p
        };
}

function makeWrap(p) {
  return {
          TAG: /* P */0,
          _0: {
            provider: p
          }
        };
}

function makeDefault(chainId) {
  return {
          provider: FloatUtil.makeDefaultProvider(FloatUtil.getChainConfigUsingId(chainId))
        };
}

function makeDefaultWrap(chainId) {
  var p = FloatUtil.makeDefaultProvider(FloatUtil.getChainConfigUsingId(chainId));
  return {
          TAG: /* P */0,
          _0: {
            provider: p
          }
        };
}

var WithProvider = {
  make: make,
  makeWrap: makeWrap,
  makeDefault: makeDefault,
  makeDefaultWrap: makeDefaultWrap
};

function make$1(w) {
  return {
          wallet: w
        };
}

function makeWrap$1(w) {
  return {
          TAG: /* W */1,
          _0: {
            wallet: w
          }
        };
}

var WithWallet = {
  make: make$1,
  makeWrap: makeWrap$1
};

function makeLongShortContract(p, c) {
  return FloatContracts.LongShort.make(Ethers.utils.getAddress(c.contracts.longShort.address), p);
}

function updateSystemStateMulti(wallet, config, marketIndexes) {
  var partial_arg = makeLongShortContract(FloatEthers.wrapWallet(wallet), config);
  return function (param) {
    return partial_arg.updateSystemStateMulti(marketIndexes, param);
  };
}

function contracts(chain) {
  var tmp;
  tmp = chain.TAG === /* P */0 ? FloatUtil.getChainConfig(FloatEthers.wrapProvider(chain._0.provider)) : FloatUtil.getChainConfig(FloatEthers.wrapProvider(chain._0.wallet.provider));
  return tmp.then(function (c) {
              return c.contracts;
            });
}

function market(chain, marketIndex) {
  if (chain.TAG === /* P */0) {
    return FloatMarket.WithProvider.makeWrap(chain._0.provider, marketIndex);
  } else {
    return FloatMarket.WithWallet.makeWrap(chain._0.wallet, marketIndex);
  }
}

function updateSystemState(chain, marketIndexes, txOptions) {
  return FloatUtil.getChainConfig(FloatEthers.wrapWallet(chain.wallet)).then(function (config) {
              return updateSystemStateMulti(chain.wallet, config, marketIndexes)(txOptions);
            });
}

exports.wrapSideP = wrapSideP;
exports.wrapSideW = wrapSideW;
exports.WithProvider = WithProvider;
exports.WithWallet = WithWallet;
exports.makeLongShortContract = makeLongShortContract;
exports.updateSystemStateMulti = updateSystemStateMulti;
exports.contracts = contracts;
exports.market = market;
exports.updateSystemState = updateSystemState;
/* ethers Not a pure module */
